
当 panic 被调用时，当前函数的执行会立即停止，然后开始执行该函数中已经 defer 的函数。之后，panic 会向上传播到调用栈的上一层函数，重复这个过程，直到整个 goroutine 终止。
Go 不支持传统的 try-catch 异常机制，但可以通过 defer + recover 来捕获 panic，从而防止程序崩溃。

最佳实践建议：
- 尽量使用 error 而不是 panic 来处理常规错误。
- 只在真正“不可能”发生的情况下使用 panic。
- 在库代码中应避免使用 panic，而应返回 error。
- 在 main 函数或 goroutine 的最外层可以使用 defer + recover 做兜底处理，防止程序意外退出。


为什么 Go 不使用 try...catch？
- 迫使程序员在代码中显式地处理错误，从而避免了错误被“跳过”。程序逻辑中正常流程的一部分，应该被显式地处理，而不是通过异常机制“跳转”到错误处理代码。
- 难以追踪错误：一旦抛出异常，程序会跳出当前函数栈，跳到最近的 catch 块。这种“非局部跳转”让代码的执行路径变得难以追踪。